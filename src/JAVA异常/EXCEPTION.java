package JAVA异常;
//1.异常的定义
/*
异常就是将程序运行当中出现了不正常的现象导致程序发生了中断现象。
在JAVA之中我们将各种异常进行了抽象以及统一形成了抽象类。
* */

//2.为什么我们需要进行异常处理
/*
因为在理想状态下，通常是我们对程序进行调试的时候，
用户输入数据的格式永远都是正确的，选择打开的文件也一定是存在的，
这样的话就不会出现程序的异常中断。
一旦发生异常中断的话，用户的操作就会全部损失，
用户就有可能不再需要这个程序了。

* */

//3.异常处理需要完成的几点
/*
异常处理的话我们首先要想用户通报错误，
然后保存所有的工作结果，允许用户以妥善的方式进行程序的退出，
或者返回到一种安全的状态让用户进行重新的操作。
* */

//4.错误的类型：
/*
*
1.用户输入错误，有些用户我们提示他让他进行什么样的输入，他偏不进行什么样的输入导致程序发生错误，如假定让用户输入url但是用户输了乱七八糟的错误，网络层就会发出警告。
2.设备错误，硬件经常会出现客观问题，举个例子，比如打印机没有纸了就无法进行打印了。
3.物理限制,比如说存储空间已经耗尽。
4.代码错误，代码错误就是属于我们程序员代码的不严谨不规范造成的，比如说我们让一个空的栈进行弹出操作而不进行事先的判空操作。
* */

//5.如何处理抛出的错误
/*
对于这些方法之中的错误传统的做法是返回一个错误码，
错误码通常不是标准字符而是一个-1，但是并不能够在
所有的情况之下我们都能够通过返回-1来表示错误，因
为-1可能是一个完全合法的结果。然后我们怎么进行解决
呢，在JAVA之中如果某个方法不能够按照正常的路径进
行解决那么就可以通过另外一个路径退出方法，在这种
情况下方法不会返回任何值，而是抛出了一个包裹了异
常信息的异常对象，然后异常处理器将进行捕获，然后
继进行相应的处理，如果没有捕获将进行继续的抛出。
* */

//6.JAVA异常分类的分析
/*
* 从图中我们可以知道Throwable类(意为可以抛出的)是Object的子类
* 然后Error和Exception分别是Throwable的子类，其中Error我们无
* 法进行处理，因为它是JVM的报错，其可能揭示的是JAVA运行时系统内
* 部的错误和资源耗尽错误，然后Exception是程序员需要进行处理的。
*
* 我们注意到Exception主要有两个子类，其中有IOException称为受
* 检异常，和RuntimeException,为什么IOException称之为是受检
* 异常呢，因为它取决于客观因素，而不仅仅是取决于代码，比如说
* 我们的FileNotFoundExcption,它取决于客观原因即用户输入的
* 文件名可能是不存在的，而如果一旦发生了RuntimeException那
* 就是我们程序员的问题了，比如说ClassCastException如果出现
* 了这个异常的话就说明我们可能将一个基类对象强转成为了子类对象
* 或者说我们没有提前使用instanceOf进行判断。
 *
*
* */

//7.如何声明受查异常
/*
* 如何进行声明一个方法之中可能会向上抛出异常呢，我们直接在方
* 法的后面加上  throws 异常类名 即可，比如说一个方法需要进
* 行文件的打开的话，要么可以在内部进行try
  Catch进行消化，要么声明这个方法可能会抛出FileNotFoundExcption
  异常，使用throws关键字，如果一旦文件不存在，打开失败会抛出一个
  这种异常类对象，然后运行时系统就会搜索处理器，如果没有捕获到就
  一直上抛，直到主方法都没有处理器处理这个异常，最终导致程序的中断。
*
*
* throws 的使用：如果一个方法可能会抛出多种类型的异常，我们可以使
* 用逗号将这些不同类型的异常进行隔开。

* */

//8.主动进行异常的抛出
/*
* 我们只需要创建异常类对象然后
  throw 对象名 即可，在JAVA之中我们只能够
  抛出Throwable子类的对象。
* */

//9.异常类的创建
/*
* 在程序之中可能会出现任何标准的异常类都无法描述的异常，
* 这个时候就需要我们自己主动的进行异常类的创建。我们需
* 要做的是从Exception类派生出一个资料类，定义类的时候
* 我们需要创建两个构造器，一个构造器是默认的构造器，一
* 个构造器包含有错误的详细的描述信息，Throwable的toString
* 方法可以将错误的信息进行详细的打印。然后我们就可以进行
* 异常类型的抛出了。
*
* */

//10.Throwable的三个方法
/*
1.Throwable()构造一个新的Throwable对象
2.Throwable(String message)构造一个包含有特殊信息的Throwable对象。
3.String getMessage()获得Throwable对象的详细的描述信息。
* */

//11.异常的捕获(最完整的捕获异常的结构)
/*
try
{
可能抛出异常的语句块
}
catch(异常类型1 e)
{
处理抛出的异常类型1对象；
}
catch(异常类型2 e)
{
处理抛出的异常类型2对象；
}
finally
{
无论发生什么情况都将进行执行的语句块。
}

* */

//12.finally子句
/*
如果方法抛出了一个异常就会终止方法剩余代码的执行，
如果这整个代码在之前获取到了本地的一些资源，但是
后面的那些归还资源释放资源的操作没有被执行，那就
会出现资源的浪费。所以就出现了我们的finally子句，
不论有没有异常被捕获都会执行finally子句。
* */

//13.带有资源的try语句
/*
try(Scanner in  =  new Scanner(new FileInputStream(路径)，“utf-8“))
{
}
当这个块进行正常退出的时候或者其间有一个异常被抛出的时候都会调用in.close方法
* */

//14.再次进行异常的抛出以及异常链
/*
我们catch子句之中通常是用来进行异常的处理的，try子句之中是用来进行异常的抛出的，但是也有例外的情况发生，即 catch子句之中也可以进行异常对象的抛出。我们在这里面进行抛出的原因是因为我们想要改变抛出异常类对象的类型。
如何在将一个新的异常抛出的时候保存原始捕获到的异常呢：我们可以使用
Try
{
操作数据库的语句，可能抛出异常
}
Catch(SQLException e)
{
Throwable se = new ServletException(“database error“)
se.initCause(e);//这里我们将原始异常设置为新的异常的原因
throw se;//进行新的异常的抛出
}
然后我们如果想要获得原始异常直接调用
Throwable getCause();方法即可。
* */

//15.分析堆栈轨迹的常用方法
/*
1.StackTraceElement[ ] getStackTrace();
2.void printStackTrace();
* */

//16.StackTraceElement类之中分析堆栈轨迹的方法:
/*
*
String getFileName()
Int getLineNumber()
String getClassName()
String getMethodName()
String isNativeMethod()
String toString()
* */
public class EXCEPTION {
}
